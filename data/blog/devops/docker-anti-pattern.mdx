---
title: 'Docker Anti Patterns'
date: '2022-10-26'
tags: ['devops', 'container', 'docker']
draft: false
images: ['/static/images/ogps/docker_anti_patterns.jpeg']
summary: 'Trong bài viết này, chúng ta sẽ trình bày một số phương pháp không tốt, các anti-pattern khi sử dụng container và giải pháp cải thiện cho từng phương pháp.'
---

![Docker Anti Pattern](/static/images/ogps/docker_anti_patterns.jpeg)

Container đang bùng nổ và trở thành một công nghệ được sử dụng rộng rãi trong những năm gần đây. Ngay cả khi bạn chưa tin rằng Kubernetes sẽ là công nghệ tốt trong tương lai, thì việc sử dụng Docker thôi cũng mang lại nhiều giá trị. Container có thể đơn giản hóa cả việc triển khai và các CI/CD pipelines.

Trang web chính thức của Docker trình bày về các phương pháp tốt nhất của Docker và thường nó sẽ có tính kỹ thuật cao, tập trung nhiều hơn vào cấu trúc của Dockerfile thay vì thông tin chung về cách sử dụng container. Một người mới sử dụng Docker đến một lúc nào đó sẽ hiểu về các layer của Docker, cách chúng được lưu vào bộ nhớ cache và cách tạo Docker image nhỏ. Việc sử dụng multi-stage builds cũng không quá khó.

Tuy nhiên, vấn đề chính của việc sử dụng container là các công ty không có khả năng nhìn vào bức tranh lớn hơn và đặc biệt là tính chất bất biến của container/image. Một số công ty đặc biệt cố gắng chuyển đổi các quy trình dựa trên VM hiện có của họ thành các thùng chứa với kết quả không rõ ràng. Có rất nhiều thông tin về các chi tiết low-level của container (cách tạo và chạy chúng), nhưng rất ít thông tin về các phương pháp tốt nhất ở high-level.

Để thu hẹp khoảng cách của các tài liệu này, tôi sẽ trình bày danh sách các phương pháp tốt nhất của Docker ở high-level. Hy vọng rằng, bài viết sẽ cung cấp cho bạn một số hiểu biết về cách bạn nên sử dụng container.

Dưới đây là danh sách đầy đủ các phương pháp không tốt mà chúng ta sẽ kiểm tra:

1. Cố gắng sử dụng các phương pháp áp dụng với VM trên container.
2. Tạo tệp Docker không trong suốt.
3. Tạo Dockerfiles có tác dụng phụ bên ngoài.
4. Nhầm lẫn giữa image dùng để triển khai với image dùng trong quá trình phát triển.
5. Build các image khác nhau cho mỗi môi trường.
6. Kéo mã từ git vào máy chủ sản xuất và build image on-the-fly.
7. Thúc đẩy băm git giữa các nhóm.
8. Hard-code các giá trị bí mật trong image.
9. Sử dụng Docker làm CI/CD cho người nghèo
10. Cho rằng các container là một phương pháp đóng gói ngu ngốc.

<TOCInline toc={props.toc} asDisclosure />

## Anti-pattern 1 - Coi Docker container như máy ảo (VM)

Trước khi đi vào một số ví dụ thực tế hơn, chúng ta hãy tìm hiểu lý thuyết cơ bản trước. **Các container không phải là máy ảo**. Thoạt nhìn, chúng có thể trông như chúng hoạt động giống VM nhưng sự thật lại hoàn toàn khác với những câu hỏi như:

1. [Làm cách nào để cập nhật các ứng dụng đang chạy bên trong container?](https://unix.stackexchange.com/questions/123482/application-updates-inside-of-docker-containers)
2. [Làm cách nào để ssh vào Docker container?](https://stackoverflow.com/questions/28134239/how-to-ssh-into-docker)
3. [Làm cách nào để lấy nhật ký/tệp từ container?](https://stackoverflow.com/questions/44744188/docker-how-to-see-the-logs-of-running-application-inside-docker-container)
4. [Làm cách nào để áp dụng các bản sửa lỗi bảo mật bên trong vùng chứa?](https://serverfault.com/questions/611082/how-to-handle-security-updates-within-docker-containers)
5. [Làm cách nào để chạy nhiều chương trình trong một vùng chứa?](https://stackoverflow.com/questions/19948149/can-i-run-multiple-programs-in-a-docker-container)

Tất cả những câu hỏi này đều đúng về mặt kỹ thuật, và những người đã trả lời chúng cũng đã đưa ra những câu trả lời chính xác về mặt kỹ thuật.

> Làm cách nào để tôi có thể bỏ tất cả các phương pháp, quy trình áp dụng với VM để thay đổi quy trình làm việc với các container không trạng thái, bất biến, tồn tại trong thời gian ngắn (stateless, immutable, short-lived) thay vì các máy ảo có trạng thái, hoạt động lâu dài, có thể thay đổi (stateful, long-running, mutable)?

Nhiều công ty ngoài kia đang cố gắng sử dụng lại các phương pháp/công cụ/kiến thức tương tự từ máy ảo cho container. Một số công ty thậm chí chưa hoàn thành việc chuyển đổi từ bare-metal sang VM khi các container xuất hiện.

Việc học lại điều gì đó là rất khó. Hầu hết những người bắt đầu sử dụng container đều xem chúng ban đầu như một lớp trừu tượng bổ sung bên trên các phương pháp hiện có của họ:

![Containers không phải VMs](/static/images/assets/docker_anti_patterns_vmnotcontainer.png)

<p align="center">
  <small>Containers không phải VMs (Nguồn: [codefresh.io](https://codefresh.io/))</small>
</p>

Trong thực tế, containers yêu cầu một cái nhìn hoàn toàn khác và thay đổi các quy trình hiện có.

![Container yêu cầu một cách suy nghĩ mới](/static/images/assets/docker_anti_patterns_container.png)

<p align="center">
  <small>
    Container yêu cầu một cách suy nghĩ mới (Nguồn: [codefresh.io](https://codefresh.io/))
  </small>
</p>

Không có cách khắc phục nào dễ dàng cho anti-pattern này ngoài việc học và hiểu về bản chất của các containers, các khối xây dựng và lịch sử của chúng.

Nếu bạn thường xuyên thấy mình muốn ssh đến các container đang chạy để "nâng cấp" chúng hoặc lấy nhật ký/tệp theo cách thủ công, bạn chắc chắn đang sử dụng Docker sai cách và bạn cần đọc thêm về cách các container hoạt động.

## Anti-pattern 2 - Tạo Docker image không trong suốt

**Một Dockerfile phải minh bạch và độc lập. Nó phải mô tả rõ ràng tất cả các thành phần của một ứng dụng. Bất kỳ ai cũng có thể nhận được cùng một Dockerfile và tạo lại cùng một image. Các bước "magic" nên được tránh.**

Dưới đây là một ví dụ không tốt:

```yaml
FROM alpine:3.4

RUN apk add --no-cache \
      ca-certificates \
      pciutils \
      ruby \
      ruby-irb \
      ruby-rdoc \
      && \
    echo http://dl-4.alpinelinux.org/alpine/edge/community/ >> /etc/apk/repositories && \
    apk add --no-cache shadow && \
    gem install puppet:"5.5.1" facter:"2.5.1" && \
    /usr/bin/puppet module install puppetlabs-apk

# Install Java application
RUN /usr/bin/puppet agent --onetime --no-daemonize

ENTRYPOINT ["java","-jar","/app/spring-boot-application.jar"]
```

Đừng hiểu lầm, tôi thích Puppet vì nó là một công cụ tuyệt vời (hoặc Ansible hoặc Chef cho vấn đề đó). Việc lạm dụng nó để triển khai ứng dụng có thể dễ dàng với máy ảo, nhưng với vùng chứa thì điều đó thật tệ hại.

Trước hết, nó làm cho Dockerfile này phụ thuộc vào vị trí của host. Bạn phải xây dựng nó trên một máy tính có quyền truy cập vào máy chủ Puppet trên môi trường production. Máy trạm của bạn có quyền truy cập vào máy Puppet trên môi trường production không? Nếu có, máy trạm của bạn có thực sự nên quyền truy cập vào máy chủ Puppet trên môi trường production không?

Nhưng vấn đề lớn nhất là Docker image này không thể được tạo lại dễ dàng. Nội dung của nó phụ thuộc vào những gì máy chủ Puppet có tại thời điểm build ban đầu. Nếu bạn xây dựng cùng một Dockerfile vào một ngày khác, bạn có thể nhận được một image hoàn toàn khác. Và nếu bạn không có quyền truy cập đến máy chủ Puppet hoặc máy Puppet không hoạt động, bạn thậm chí không thể build image ngay từ đầu. Bạn thậm chí không biết phiên bản của ứng dụng là gì nếu bạn không có quyền truy cập vào các puppet script.

Nhóm tạo Dockerfile này đã hơi lười biếng. Đã có một puppet script để cài đặt ứng dụng trong máy ảo. Dockerfile chỉ để làm điều tương tự (xem anti-pattern trước).

Cách khắc phục ở đây là có các Dockerfiles tối giản mô tả rõ ràng những gì chúng làm. Đây là ví dụ tương tự tự với một Dockerfile "nghiêm chỉnh".

```yaml
FROM openjdk:8-jdk-alpine

ENV MY_APP_VERSION="3.2"

RUN apk add --no-cache \
ca-certificates

WORKDIR /app
ADD  http://artifactory.mycompany.com/releases/${MY_APP_VERSION}/spring-boot-application.jar .

ENTRYPOINT ["java","-jar","/app/spring-boot-application.jar"]
```

Chú ý rằng:

- Không có sự phụ thuộc vào cơ sở hạ tầng puppet. Dockerfile có thể được xây dựng trên bất kỳ máy tính nào có quyền truy cập vào kho lưu trữ nhị phân.
- Các phiên bản của phần mềm được xác định rõ ràng.
- Rất dễ dàng để thay đổi phiên bản của ứng dụng bằng cách chỉ chỉnh sửa Dockerfile (thay vì các puppet script).
- Đây chỉ là một ví dụ rất đơn giản. Tôi đã thấy nhiều Dockerfiles phụ thuộc vào các công thức "magic" với các yêu cầu đặc biệt về thời gian và địa điểm chúng có thể được tạo ra. Vui lòng không viết Dockerfiles của bạn theo cách này, vì các nhà phát triển (và những người khác không có quyền truy cập vào tất cả các hệ thống) sẽ gặp khó khăn lớn trong việc tạo Docker image trong môi trường local của họ.

Một giải pháp thay thế tốt hơn sẽ là nếu Dockerfile tự biên dịch mã nguồn Java (sử dụng multi-stage builds). Điều đó sẽ cung cấp cho bạn khả năng thể hiện rõ hơn về những gì đang xảy ra trong Docker image.

## Anti-pattern 3 - Tạo các Dockerfiles có ảnh hưởng tới bên ngoài

Hãy tưởng tượng rằng bạn là kỹ sư vận hành/SRE đang làm việc tại một công ty rất lớn, nơi sử dụng nhiều ngôn ngữ lập trình.Sẽ rất khó để trở thành một chuyên gia về tất cả các ngôn ngữ lập trình và các hệ thống build sử dụng ở đó.

Đây là một trong những lợi thế của việc áp dụng container. Bạn có thể tải xuống bất kỳ tệp Dockerfile nào từ bất kỳ nhóm phát triển nào và build tệp đó mà không cần quan tâm đến các ảnh hưởng bên ngoài nó có thể tạo ra (vì không nên có bất kỳ ảnh hưởng nào).

Việc build Docker image phải là một hoạt động lý tưởng, không quan trọng việc bạn build cùng một Dockerfile một lần hay một nghìn lần, hoặc nếu bạn xây dựng nó trên máy chủ CI trước và sau đó trên máy trạm của bạn.

Tuy nhiên, có một số Dockerfiles ngoài đó trong giai đoạn build sẽ:

1. Thực hiện các git commit hoặc các thao tác khác với git
2. Dọn dẹp hoặc xáo trộn cơ sở dữ liệu
3. Gọi các dịch vụ bên ngoài với các thao tác POST/PUT (thay đổi dữ liệu)

Container cung cấp khả năng cách ly (isolation) với đến hệ thống tệp của host nhưng không có gì đảm bảo rằng Dockerfile sẽ không có chỉ thị RUN gửi một HTTP request cùng payload đến mạng nội bộ của bạn.

Đây là một ví dụ đơn giản trong đó một Dockerfile thực hiện việc đóng gói (hành động an toàn) và công khai (hành động không an toàn) một ứng dụng npm trong một lần chạy.

```yaml
FROM node:9
WORKDIR /app

COPY package.json ./package.json
COPY package-lock.json ./package-lock.json
RUN npm install
COPY . .

RUN npm test

ARG npm_token

RUN echo "//registry.npmjs.org/:_authToken=${npm_token}" > .npmrc
RUN npm publish --access public

EXPOSE 8080
CMD [ "npm", "start" ]
```

Dockerfile này gây nhầm lẫn giữa hai mối quan tâm khác nhau, phát hành một phiên bản của ứng dụng và tạo Docker image cho nó. Có thể đôi khi hai hành động này thực sự xảy ra cùng một lúc, nhưng đây không phải là lý do để làm một Dockerfile trở nên không gọn gàng với các ảnh hưởng phụ.

Docker **KHÔNG** phải là một hệ thống CI nói chung và nó chưa bao giờ giống như vậy. Đừng lạm dụng Dockerfile như những tập lệnh bash. Dù việc có những ảnh hưởng phụ trong container run time là điều chấp nhận được nhưng những ảnh hưởng đó được tạo ra khi trong container build time thì không.

Giải pháp là đơn giản hóa các tệp Dockerfile của bạn và đảm bảo rằng chúng chỉ chứa các logic đơn giản như:

- Clone mã nguồn
- Download các dependency
- Biên dịch và đóng gói mã Nguồn
- Xử lý/Thu gọn/Biến đổi các tài nguyên cục bộ (bên trong container)
- Chạy các scripts và sửa các tệp trên hệ thống file của container

Ngoài ra, hãy nhớ rằng cách Docker cache các layer của filesystem. Docker giả định rằng nếu một layer và các layer trước đó chưa "thay đổi" thì chúng có thể được sử dụng lại từ bộ nhớ cache. Nếu các lệnh Dockerfile của bạn có các ảnh hưởng phụ, về cơ bản, bạn đã phá vỡ cơ chế cache của Docker.

```yaml
FROM node:10.15-jessie

RUN apt-get update && apt-get install -y mysql-client && rm -rf /var/lib/apt

RUN mysql -u root --password="" < test/prepare-db-for-tests.sql

WORKDIR /app

COPY package.json ./package.json
COPY package-lock.json ./package-lock.json
RUN npm install
COPY . .

RUN npm integration-test

EXPOSE 8080
CMD [ "npm", "start" ]
```

Giả sử rằng bạn cố gắng xây dựng tệp Dockerfile này và các unit-test của bạn không thành công. Bạn thực hiện thay đổi đối với mã nguồn và build lại. Docker sẽ giả định rằng layer xoá DB đã "chạy" và nó sẽ sử dụng lại bộ nhớ cache. Vì vậy, các unit-test của bạn bây giờ sẽ chạy trong một DB chưa được xoá và chứa dữ liệu từ lần chạy trước.

Trong ví dụ này, Dockerfile rất nhỏ và sẽ dễ dàng xác định vị trí câu lệnh có ảnh hưởng phụ (lệnh mysql) và di chuyển nó đến đúng vị trí để sửa bộ nhớ cache của layer, cố gắng tìm đúng thứ tự của câu lệnh RUN rất khó nếu bạn không biết câu nào có ảnh hưởng phụ và câu nào không.

Dockerfiles của bạn sẽ đơn giản hơn nhiều nếu tất cả các hành động mà chúng thực hiện ở chế độ chỉ đọc và với phạm vi cục bộ.

## Anti-pattern 4 - Nhầm lẫn giữa image được sử dụng để phát triển với những image được sử dụng để triển khai

Trong bất kỳ công ty nào đã sử dụng container, thường có hai danh mục Docker image riêng biệt. Đầu tiên, có những image được sử dụng làm artifact để triển khai trên các máy chủ sản xuất.

Các image dùng để triển khai phải chứa:

1. Mã ứng dụng ở dạng đã được rút gọn/biên dịch kèm với các phụ thuộc cho run time của nó.
2. Không có gì khác, thực sự không có thêm bất cứ thứ gì khác.

Loại thứ hai là các image được sử dụng cho các hệ thống CI/CD hoặc dành cho các kỹ sư phát triển, cần có:

1. Mã nguồn ở dạng ban đầu (VD: chưa được thu gọn)
2. Trình biên dịch/bộ thu nhỏ/bộ chuyển đổi (Compilers/minifiers/transpilers)
3. Framework kiểm thử/các công cụ báo cáo
4. Quét bảo mật, quét chất lượng, máy phân tích tĩnh (Security scanning, quality scanning, static analyzers)
5. Các công cụ tích hợp với cloud
6. Các tiện ích khác cần thiết cho CI/CD pipeline

Rõ ràng là các danh mục container image này nên được tách biệt vì chúng có các mục đích khác nhau. Image được triển khai tới máy chủ sản xuất phải ở mức tối giản, an toàn và chắc chắn. Image được sử dụng trong quy trình CI/CD thì không bao giờ nên được triển khai ở bất cứ đâu nên chúng có yêu cầu ít nghiêm ngặt hơn nhiều (về kích thước và bảo mật).

Tuy nhiên, vì một số lý do, mọi người không phải lúc nào cũng hiểu sự khác biệt này. Tôi đã thấy một số công ty cố gắng sử dụng cùng một hình ảnh Docker cho cả quy trình phát triển và triển khai. Hầu như các tiện ích và framework không liên quan cuối cùng lại xuất hiện trong Docker image của môi trường sản xuất.

Có chính xác **0 lý do** cho việc Docker image ở môi trường sản xuất cần có git, framework kiểm thử hoặc trình biên dịch/trình thu nhỏ.

Cam kết về việc sử dụng một artifact chung để triển khai luôn là giữa các môi trường để đảm bảo rằng những gì bạn đang kiểm thử cũng là những gì bạn sẽ triển khai (sẽ được nói rõ hơn ở phần sau) là một trận thua. Nhưng cố gắng cố gắng sử dụng những gì ở môi trường local cho giai đoạn phát triển cho môi trường sản xuất sẽ không ổn.

Tóm lại, hãy cố gắng hiểu vai trò của các Docker image mà bạn sử dụng. Mỗi image nên có một vai trò duy nhất. Nếu bạn đang chuyển các framework/thư viện kiểm thử đến môi trường sản xuất thì bạn đang làm sai. Bạn cũng nên dành một chút thời gian để tìm hiểu và sử dụng [multi-stage builds](https://docs.docker.com/build/building/multi-stage/)

## Anti-pattern 5 -Sử dụng các hình ảnh khác nhau cho từng môi trường (qa, stage, production)

Một trong những lợi thế quan trọng nhất của việc sử dụng container là thuộc tính bất biến của chúng. Điều này có nghĩa là Docker image chỉ nên được xây dựng một lần và sau đó được chuyển tới các môi trường khác nhau cho đến khi nó tới môi trường sản xuất.

![Sử dụng cùng một docker image](/static/images/assets/docker_anti_patern_image-promotion-1.png)

Bởi vì với các image giống nhau sẽ được chuyển tới các môi trường dưới dạng một thực thể duy nhất, bạn có được đảm bảo rằng những gì bạn đang thử nghiệm trong một môi trường giống với môi trường khác.

Tôi thấy rất nhiều công ty xây dựng các artifact khác nhau cho từng môi trường của họ với các phiên bản hoặc cấu hình khác nhau.

![Sử dụng image khác nhau cho từng môi trường](/static/images/assets/docker_anti_pattern_image-per-env-1.png)

Điều này sẽ phát sinh vấn đề vì không có gì đảm bảo rằng các image “đủ giống nhau” và đảm bảo chúng hoạt động giống nhau. Nó cũng mở ra rất nhiều khả năng lạm dụng, nơi các kỹ sư phát triển/vận hành đang lén sử dụng các công cụ gỡ lỗi bổ sung trong các image của môi trường không sản xuất, tạo ra sự khác nhau thậm chí còn lớn hơn giữa các image cho các môi trường khác nhau.

Thay vì cố gắng đảm bảo rằng các hình ảnh khác nhau của bạn giống nhau nhất có thể, việc sử dụng một hình ảnh duy nhất cho tất cả các giai đoạn vòng đời phần mềm sẽ dễ dàng hơn nhiều.

Lưu ý rằng hoàn toàn bình thường nếu các môi trường khác nhau sử dụng các cài đặt khác nhau (VD: các biến bí mật và biến cấu hình) như chúng ta sẽ thấy ở phần sau của bài viết này. Tuy nhiên, mọi thứ khác phải hoàn toàn giống nhau.

## Tham khảo

- [Docker anti-patterns](https://codefresh.io/blog/docker-anti-patterns/)
